Введение
=========


Для кого эта книга
---------------------

Для моих друзей!!! Они закончили технические вузы. В их курсах были программы по информатике,
но они закончились на этапе перебора двумерного массива.

Также он подойдет для любому кто понимает простейшие операции в программировании и хочет понять js.
Но безусловно, каждый кто прочитает хоть одну главу - мой друг, ведь это книга для моих друзей!!!

Глава 1
=========

Сущность js.
------------

Многие вещи становятся понятны если воспринимать js как ешё одну абстракцию. Как будто вы в гостях у
иностранца. Вы ему отсылаете сигнал, а он в зависимости от того как понял отвечает вам.
Много написано про асинхронность js, какая это больщая проблема. Но нигде не проясняется, что это и почему это пока
не почитаешь исходников w3c.
Почему работает замыкание. Смысл объектов.
Чтобы понимать эти вещи нужно для начала просто принять как должное.
Что мы работаем в песочнице с черным ящиком и мы слепы(пока:-)
Трудно понять зачем нужны все эти паттерны и соглашения, которыми грузят многие руководства с самого начала.

JS работает внутри браузера(песочница) работает с api браузера(черным ящик).
JS это еще одна абстракция(одна команда на js подразумевает кучу шаблонного кода на языке с)
над низкоуровневыми языками. =>
-работает медленнее
-может вызывать ошибки на первых порах пока не освоится преобразование типов.

+легче других языков

Check out this neat program I wrote:

```
x = 0
x = 2 + 2
what is x
```



JS не типизированный язык.
типы не надо обьявлять при инициализации переменной и можно свободно менять.
также они преобразуются автоматически нужно выучить не сколько правил и ловить кайф

JS ассинхронный язык при определенных случаях выполнение кода идет не по очереди
это черный ящик.Я не нашел какой либо хорошего обьяснения, а w3c не осилил Я сделал для себя вывод,
что любое действие отданное в черный ящик и если что то там в чя понимает что не может в разумных временных
пределах отдать какие то данные. То скрипт идет дальше. А потом ЧЯ довольно кидает данные в пустоту и мащет хвостом
типа давай похвали меня. Зато все эти места известны и очень быстро запоминаются.
Если где то что то не работает ВИНОВАТА АСИНХРОННОСТЬ

Песочниц для js большое множество.
Их можно разделить на 2 вида.
Серверные(мимими) node.js и io.js(совсем недавно)
Клиентские(любой браузер). Ужасный ужас. Раньше был. Сейчас кроссбраузерная война закончилась, но
недопонятки между ними ещё встречаются.
Настоящая проблема это совместимость со старыми версиями браузеров.
В то время как из за взрыва популярности js
Многие плюшки которые будут рассказаны далее, не поддерживаются в более старых версиях браузеров.
Это ужасный ужас сейчас.

Мы будем рассматривать только последние версии браузеров. Ни за какой дурацкой ie мы парится не будем.
Но когда будем обсуждать предстоящие нововведения, я буду акцентировать на этом внимание.

Как отлаживать программу открываем любой браузер жмем F12, ищем вкладку консоли.
Ищем строку в которую можем ввести текст.

console.log('hello');

выведется строка : hello

в коде будет точно такое же действие.
Я подразумеваю, что ты уже знаешь
for(;;)
if(){}else{}
Стандартную сишную лексику которую преподают в универе, если нет - здесь этого не будет.

Приложение здесь подразумевается, что нибудь посерьезнее университетских лаб.




##Примитивы

1. Число:						1, 0.1;
2. Строка:						'Hello World!';
3. Логическое значение: 		true или false

##Переменные

В js переменные обьвляютс (создаются) ключевым словом var.
js не типизированный язык и в созданную переменную можно помещать любое значение.

```
var i = 0;
	i = true;
	i = 'Hello world!!!';
```

##Обьекты

Главный кирпичики построения скрипта js - это обьекты. В js всё является объектом.
Пока будем придерживаться понятия, что обьект -
это что-то что имеет свойства(некие значения, возможно вложенные обьекты или примитивы)
и как-то реагирует на вызовы некоторых свойств, которые мы назовем методы.

В браузере есть главный обьект window (тот самый чёрный ящик из введения). Рассмотрим этот обьект.

Откройте консоль и наберите

>window

В консоль выведется js обьект.
Если последовательно выбирать вложенные свойства, то возникает ассоциация с файловой системой.

Например путь к рабочему столу в ОС Microsoft Windows

>c/users/userName/Desktop

Путь к константе числа Пи содержащейся в обьекте Math который принадлежит непосредственно обьекту window.
Кстати введите этот путь в консоль.

>window.Math.PI

Представим что обьекты - это папки. Входя в папку мы видим другие папки, в которые тоже можем войти.
В папках есть и другие файлы, которые можно ассоциировать со свойствами обьекта. А программы - с методами.

Так и в обьектной модели браузера. Вызывая обьект мы получаем доступ к вложенным обьектам,
а также к свойствам и методам.

##Сборщик мусора

Обьект занимает какую то область в памяти компьютера и если неудалять ненужные обьекты,
то легко можно "уронить" браузер.

В js память освобождается автоматически сборщиком мусора(garbage collector, GK далее)

Момент вызова GK зависит от браузера и нам не подвластен(мы же помним что мы находимся в песочнице).
GK анализирует состояние и уничтожает ненужные обьекты.

Нам важно понимать как GK понимает, что можно уничтожать, а что нет. Это к счастью не секрет.

Вернемся к нашей ассоциации с файловой системой.

Если мы не можем войти в какую то папку двигаясь из корневой папки, то смысла в ней нет,
соответсвенное её можно уничтожить.

Так и в обьектной модели браузера. Если из обьекта window последовательно двигаясь нельзя добраться  до объекта,
значить до него вообще нельзя добраться и GK уничтожает его.

##Функции

Как уже говорилось раньше в js всё является объектом. Особым случаем является обьект function.
Для создания этого обьекта есть несколько способов.

№1. Создаем используя ключевое слово function и имя функции. В данном примере имя функции func.
В () указываем переменные, которые мы ожидаем получить. В данном случае a.
```
function func (a) {
	var b = 'Hello ';
	return b + a;
}
```
Ключевое слово return это то что вернет(отдаст) функция после вызова.В данном случаае строковый прмитив 'Hello '

Вызываем. Имя функции и (то что мы хотим передать функции).
```
func('world')
```

##Области видимости

В сложный скрипт состоящий из нескольких скриптов полезно разделять на области видимости.
Область видимости это обьект который содержит переменные которые недоступны вне его.


В js области видимости ограничиваются

```
// глобальная область видимости
function() {
	// вот здесь новая область видимости (локальная)
}
```


Поэтому всех программистов в свитерах с оленями очень бесило, что это не область видимости.



for(var i = 0; i < 3; i++) {
	for(var i = 0; i < 3; i++) {
		console.log(i);
	}
}


Когда очень много разработчиков пишет код они все создают одинаковые переменные.
Сначала это кажется чем то не реальным когда строчишь калькуляторы.
Быстрее всего шишки набиваются когда производится обход двумерного массива.

Вместо 9 обходов, получим только 3. Так как в одной области видимости возможно только одна переменная с
данным именем.


Среди программистов это называется поднятием или всплытием переменных.
var i;
for(i = 0; i < 3; i++) {
	for(i = 0; i < 3; i++) {
		console.log(i);
	}
	// после выхода из цикла i = 3 и условие во внешнем цикле сразу порется
}


Но в версии es6 это добавили, но с некоторой вместо var для объявления переменных надо
использовать let

```
{
	let
}
```
##Область видимости во время выполнения функции

Во время выполнения функции:

1. Создаётся область видимости - контекст исполнения функции.
Это еще один короткоживущий обьект, который содержит
2. Функции доступны данные из контекста.
3. После выполнения - контекст уничтожается.

Метод обьекта это свойство которое содержит в себе функцию.

##Объект console и метод console.log.

Обьект которым вы будете больше всего пользоваться. А конкретнее методом console.log().
Данный метод выводит данные, передаваемые в него во время выполнения скрипта.

```
var a = 'Hello';
console.log(a);
console.log('world!!!');
```

Метод не заменим при отладке скрипта. У обекта console есть и другие методы,
но они не важны на данном этапе.

##Анонимные функции

Объвляются как и функции но не имеют имени.

Например:

Объявление
```
var func = function (a) {
		return a;
	}
```
Вызов
```
func('hello')
```
Правая часть присвоения ни что иное как анонимная функция.

Главное достоинство анонимных функций - это возможность создания функций высшего порядка (функции создающие другие функции).
```
var func = function (a) {
		return function () {
					return a;
				};
	}

var a = func('hello');

a()
```
Подробнее про функций высшего порядка в следующей главе.





##Эта глава про замыкания

Области видимости и сборщик мусора создают замыкания(не совсем так, но так).

Когда мы создаем обычную функцию:
function func() {
	var hello = 'hello';
	console.log(hello)
}

func()

После выполнения функции контекст теряет связь с глобальным объектом window,
следовательно и все переменные обьявленные в этом контексте тоже теряют связь.
GK уничтожает контекст и мы уже не можем получить данные из него. Это плохо.

А теперь замыкание!!!

function closure(a) {
	return function (v) {
		return a + 5 + v
	}
}

var b = closure(7);

В переменную b присвоилась анонимная функция, которая ссылается на данные в контексте функции closure. Так как на контекст
closure остались ссылки из window, GK не может уничтожить контекст. Та-да-м-ммм!!!

console.log(b(8));
console.log(b(100));

этои есть замыкание, кажется что слишком просто и поэтому не верится но на самом деле

Вы полюбите этот гибкий механизм с практикой.


##Эта глава про замыкания super

эт все
пример инкапсуляции
function() {
	var g = 2;
	return function (go) {
		return go/g;
	}
}

мы не можем получить g ни как!!!


Если на обьект не остается ссылок его уничтожает gk. Прикол замыкания в том что из функции можно вернуть функцию



##Наследование
Один из столпов ООП.
Когда обьекты созданные по подобию какого нибудь обьекта имеют доступ ко всем его свойствам и методам.



Глава 2
=========
