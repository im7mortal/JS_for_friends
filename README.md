Введение
=========


Глава 1
=========




##Сущность js.
Многие вещи становятся понятны если воспринимать js как ешё одну абстракцию. Как будто вы общаетесь
с иностранцем. Вы ему отсылаете сигнал, а он в зависимости от того как понял отвечает вам.
Много написано про асинхронность js, какая это больщая проблема. Но нигде не проясняется, что это и почему это пока
не почитаешь исходников w3c.
Почему работает замыкание. Смысл объектов.
Чтобы понимать эти вещи нужно для начала просто принять как должное.
Что мы работаем в песочнице с черным ящиком и мы слепы(пока:-)
Трудно понять зачем нужны все эти паттерны и соглашения, которыми грузят многие руководства с самого начала.

JS работает внутри браузера(песочница) работает с api браузера(черным ящик).
JS это еще одна абстракция(одна команда на js подразумевает кучу шаблонного кода на языке с)
над низкоуровневыми языками. =>
-работает медленнее
-может вызывать ошибки на первых порах пока не освоится преобразование типов.

+легче других языков

Check out this neat program I wrote:

```
x = 0
x = 2 + 2
what is x
```



JS не типизированный язык.
типы не надо обьявлять при инициализации переменной и можно свободно менять.
также они преобразуются автоматически нужно выучить не сколько правил и ловить кайф

JS ассинхронный язык при определенных случаях выполнение кода идет не по очереди
это черный ящик.Я не нашел какой либо хорошего обьяснения, а w3c не осилил Я сделал для себя вывод,
что любое действие отданное в черный ящик и если что то там в чя понимает что не может в разумных временных
пределах отдать какие то данные. То скрипт идет дальше. А потом ЧЯ довольно кидает данные в пустоту и мащет хвостом
типа давай похвали меня. Зато все эти места известны и очень быстро запоминаются.
Если где то что то не работает ВИНОВАТА АСИНХРОННОСТЬ

Песочниц для js большое множество.
Их можно разделить на 2 вида.
Серверные(мимими) node.js и io.js(совсем недавно)
Клиентские(любой браузер). Ужасный ужас. Раньше был. Сейчас кроссбраузерная война закончилась, но
недопонятки между ними ещё встречаются.
Настоящая проблема это совместимость со старыми версиями браузеров.
В то время как из за взрыва популярности js
Многие плюшки которые будут рассказаны далее, не поддерживаются в более старых версиях браузеров.
Это ужасный ужас сейчас.

Мы будем рассматривать только последние версии браузеров. Ни за какой дурацкой ie мы парится не будем.
Но когда будем обсуждать предстоящие нововведения, я буду акцентировать на этом внимание.

Как отлаживать программу открываем любой браузер жмем F12, ищем вкладку консоли.
Ищем строку в которую можем ввести текст.

console.log('hello');

выведется строка : hello

в коде будет точно такое же действие.
Я подразумеваю, что ты уже знаешь
for(;;)
if(){}else{}
Стандартную сишную лексику которую преподают в универе, если нет - здесь этого не будет.




#Эта глава про области видимости

1)Области видимости. Понятие из программирования(а мы тогда чем занимаемся).
В js области видимости ограничиваются
function() {
	// вот здесь новая область видимости
}


В тяжелых языках область видимости это любое
{

}


Поэтому всех программистов в свитерах с оленями очень бесило, что это не область видимости.



for(var i = 0; i < 3; i++) {
	for(var i = 0; i < 3; i++) {
		console.log(i);
	}
}


Когда очень много разработчиков пишет код они все создают одинаковые переменные.
Сначала это кажется чем то не реальным когда строчишь калькуляторы.
Быстрее всего шишки набиваются когда производится обход двумерного массива.

Вместо 9 обходов, получим только 3. Так как в одной области видимости возможно только одна переменная с
данным именем.


Среди программистов это называется поднятием или всплытием переменных.
var i;
for(i = 0; i < 3; i++) {
	for(i = 0; i < 3; i++) {
		console.log(i);
	}
	// после выхода из цикла i = 3 и условие во внешнем цикле сразу порется
}


Но в версии es6 это добавили, но с некоторой вместо var для объявления переменных надо
использовать let

{
let
}







##Обьекты

В js главный кирпичик это обьекты. Какая то сущность, которая имеет свойства и как то реагирует на вызовы

Обьект занимает какую то область в памяти и если его не подчищать легко повалить браузер.
Чтобы разработчик не перегружался, в js память освобождается автоматически сборщиком мусора(garbage collector, GK дал.)

Нужно понимать как GK понимает что мусор а что нет.
В браузере есть глобальный объект window.

Откройте консоль и наберите

>window

Появится js обьект.Если последовательно выбирать свойства, то возникает ощущение вложенности.

Это очень похоже на файловую систему.

c/windows/system32/config

window.Math.PI

Представим что обьекты это папки. Входя в папку мы видим другие папки, в которые тоже можем войти.
Если мы не можем войти в какую то папку из корневой папки, то смысла в ней нет, соответсвенное её можно уничтожить.

Так и в обьектной модели браузера. Если последовательно двигаясь до объекта нельзя добраться из обьекта window,
значить до него вообще нельзя добраться и GK уничтожает его.

#Сборщик мусора

с какой то перидичностью вызывается GK (зависит от браузера)
GK анализирует состояние и понимает что funk больше не вызывается и ссылок на неё нет
можно зачищать

обьект функции является
GK зачищает его.

#Примитивы

1. Число:						1, 0.1;
2. Строка:						'Hello World!';
3. Логическое значение: 		true или false

Для них существуют объектные обёртки, но ими пользоваться вредно!!!
К тому же все важные свойства и методы доступны и без обертки.

#Функции

Как уже говорилось раньше в js всё является объектом.

Объявление

function func (a) {
	var b = 'Hello ';
	return a;
}

Вызов.  Имя функции и ().  () главный признак функции.

func()

Во время выполнения функции:

1. Создаётся область видимости - контекст исполнения функции.
2. Функции доступны данные из контекста.
3. После выполнения - контекст уничтожается.

#Анонимные функции

Объвляются как и функции но не имеют имени.

Например:

Объявление

var func = function (a) {
		return a;
	}

Вызов

func('hello')

Правая часть присвоения ни что иное как анонимная функция.

Главное достоинство анонимных функций - это возможность создания функций высшего порядка (функции создающие другие функции).

var func = function (a) {
		return function () {
					return a;
				};
	}

var a = func('hello');

a()

Подробнее про функций высшего порядка в следующей главе.





#Эта глава про замыкания

Области видимости и сборщик мусора создают замыкания(не совсем так, но так).

Когда мы создаем обычную функцию:
function func() {
	var hello = 'hello';
	console.log(hello)
}

func()

После выполнения функции контекст теряет связь с глобальным объектом window,
следовательно и все переменные обьявленные в этом контексте тоже теряют связь.
GK уничтожает контекст и мы уже не можем получить данные из него. Это плохо.

А теперь замыкание!!!

function closure(a) {
	return function (v) {
		return a + 5 + v
	}
}

var b = closure(7);

В переменную b присвоилась анонимная функция, которая ссылается на данные в контексте функции closure. Так как на контекст
closure остались ссылки из window, GK не может уничтожить контекст. Та-да-м-ммм!!!

console.log(b(8));
console.log(b(100));

этои есть замыкание, кажется что слишком просто и поэтому не верится но на самом деле

Вы полюбите этот гибкий механизм с практикой.


#Эта глава про замыкания

эт все
пример инкапсуляции
function() {
	var g = 2;
	return function (go) {
		return go/g;
	}
}

мы не можем получить g ни как!!!


Если на обьект не остается ссылок его уничтожает gk. Прикол замыкания в том что из функции можно вернуть функцию



##Наследование
Один из столпов ООП.
Когда обьекты созданные по подобию какого нибудь обьекта имеют доступ ко всем его свойствам и методам.



Глава 2
=========
